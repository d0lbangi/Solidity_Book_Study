# 아래 공부하면서 모르는 부분 정리 및 요약하여 깔끔하게 작성하기. (~ 7/16일까지)


public 을 변수에 정의하면 그 변수의 값을 반환하는 getter 함수가 자동으로 생성된다

함수의 반환값을 명시하는 부분에서 반환값의 returns() 부분에 반환값의 자료형을 명시하면서 반환될 변수를 선언했기 때문이다.

모디파이어는 특정한 기능을 미리 정의해 여러 함수에 적용할 수 있다. 일반적으로 모디파이어를 통해 함수의 로직에 제약을 준다.
(pure, view, payable)
 - pure: pure모디파이어를 함수에 적용하면 함수 밖에 선언된 변수를 pure가 적용된 함수 내부로 갖고 올 수 없다. 다시 말하면,
   pure가 적용된 함수는 오직 순수하게 함수 내부에서 정의된 변수 또는 매개변수만 함수 내부에 선언할 수 있다.

 - view: view 모디파이어는 pure보다 족므 더 느슨하다. view가 적용된 함수는 함수 외부에 정의된 변수를 읽을 수 있다. 그러나
   읽어 들인 변수의 값을 함수 내부에서 바꿀 수는 없다. 예를 들어 함수 외부에서 정의된 변수 a가 있을 때 view가 적용된 함수 내부에서
   a의 값을 변경한다면 오류가 발생할 것이다.

자료형 uint는 값 타입에 속하므로 함수를 실행할 때 매개변수의 저장공간을 지정해주지 않았다. 
반면에 배열 형태를 갖고 있는 bytes와 string은 참조 타입에 속하므로 memory를 따로 명시했다.
참조 타입에는 배열, 매핑, 구조체가 있으며, 이 자료형들을 함수에 선언하려면 저장공간을 나타내는 memory를 따로 지정해야 한다.

고정 크기를 가진 배열 형태의 바이트에 값을 대입할 때 bytes1 = 0x11 처럼 0x를 붙여서 16진수 값을 넣었다
동적 크기를 가진 배열인 바이트는 값을 대입할 때 0x를 붙이면 오류가 발생할 것이다.
동적 크기를 가진 배열 타입의 바이트에서는 16진수 리터럴을 표현하는 키워드 hex를 붙여서 bytes memory byt = hex"01"처럼 명시해야 한다.
고정 크기 배열에 키워드 hex를 지정해 값을 대입할 수 있으므로 bytes1 = 0x11는 bytes1 = hex"11";과 같다.

external 함수에 참조 타입의 매개변수를 입력할 때 callldata를 지정해야 한다.
주로 가시성 지정자 external이 적용된 함수의 매개변수는 콜데이터 공간을 사용하므로 참조 타입 매개변수에 키워드 calldata를 명시해야 한다.
uint나 boolean 같은 값 타입 매개변수는 키워드 calldata를 따로 명시하지 않아도 된다.


함수 외부에 변수가 선언되는 경우 스토리지에 저장된다. 변수가 스토리지에 저장된다는 것은 영속적인 속성을 갖는다는 뜻이다.
영속적인 속성을 가졌기에 상태 변수는 함수 내부나 어디서든 사용 가능하다.

상태 변수 - 함수 외부에 선언되는 변수
지역 변수 - 메모리에 저장되는 변수(함수나 반복문이 실행될 때 그 내부에 있는 함수의 매개변수, 반환값, 내부에 정의된 변수들이 저장)
전역 변수 - 블록체인의 정보(블록의 현재 번호, 블록의 시간과 같은 정보)를 나타냄

4개의 가시성 지정자 중 external은 변수에 적용할 수 없다.

솔리디티의 조건문과 박본문의 가장 큰 특징은 함수 내부에서만 작동한다는 것이다.

delete 키워드를 선언해 매핑의 값을 삭제한다.
balances[_key] = 0 와 같이 삭제하는 방식은 매핑의 값이 uint 일때만 가능하다.

배열에는 자료형이 같은 한 개 이상의 값을 순차적으로 저장한다.
인덱스는 값을 추가 할 때마다 순차적으로 증가한다.

선택한 _index의 배열의 값을 지우는 것이이지 배열의 크기는 줄어들지 않는다.
delete에 의해 삭제된 값은 정수형 배열일 경우 0으로 덮어씌우기 때문이다. 삭제하고자 하는 배열의
자료형이 문자열이면 공백으로 덮어씌운다.
즉, 매핑에서도 봤듯이 delete 키워드를 사용하면 배열의 자료형의 기본값으로 배열을 덮어쓴다.

구조체 - 사용자 정의 자료형, 자신이 원하는 자료형을 만들어서 변수, 매핑, 배열 등과 같이 자료형을 명시해야 하는 곳에 적용
          - 한 개 이상의 변수가 집단으로 구성
          - string name과 같이 저장 공간인 memory 를 입력할 필요가 없다.

변수의 자료형이 구조체일 경우 구조체 명과 구조체 내부에 정의된 변수의 순서에 맞게 입력해야 한다.

구조체 자료형을 가진 반환값을 memory에 저장한다. 구조체 자료형은 참조 타입이기에 함수 내부에서는 저장공간을 명시해야 한다.
구조체 자료형을 가진 데이터를 반환하려면 memory와 같은 저장공간을 지정해야 한다.

아무런 값을 입력하지 않았으면 구조체 자료형에 선언된 변수들의 기본값이 입력된다.

가시성 지정자가 public 이면 버튼이 나온다.

값 타입은 값이 할당되거나 함수 인자로 활용되면 값 자체가 복사된다

참조 타입은 현재 값의 주소만 복사된다.
참조 타입은 값 자체가 아닌 솔리디티 내부적으로 저장된 값을 가리키는 주소를 복사라한다. 값의 주소를 통해서 저장된 값에 접근한다.
같은 값의 주소를 공유하므로 서로에게 영향을 주고 받는 것이다.

두 참조 타입이 memory에 명시될 경우 서로 값을 가리키는 주소를 공유하며 서로 영향을 주고 받는다.
만약 두 배열이 memory에 저장되어 있으면 매개변수로 입력될 값의 주소를 공유한다.

매개변수에 storage를 명시할 때는 가시성 지정자가 internal이나 private이어야 한다. public, external은 불가능하다.

매핑 자체를 함수의 매개변수로 넘길 때 storage로 명시해야 한다.
매개변수에 storage를 쓰는 이유는 배열의 경우 push나 pop을 통해 값을 추가 및 삭제하기 위해,
그리고 매핑의 경우 매핑 자체를 매개변수로 받기 위해서
배열의 경우 매개변수에 storage를 쓰는 이유는 스토리지에 존재하는 배열을 매개변수로 받아서 값을 추가 또는 삭제할 수 있기 때문
매개변수에 storage를 써서 배열의 값을 추가하면 함수의 이점인 재사용성과 유지보수의 이점을 얻을 수 있다.

매개변수에 storage를 적용함으로써 참조 타입의 값을 좀 더 편리하게 관리할 수 있다.

함수 외부에 배열로 저장한다면 storage에 저장된 것이다.

[데이터 저장공간에 따른 참조 타입의 저장 방식]
- memory 와 memory - 주소 복사 - memory에 저장된 변수를 다른 memory 변수에 대입 시 값을 가리키는 주소를 공유해서 서로에게 영향을 줄 수 있음
- storage 와 local storage - 주소 복사 - storage에 저장된 변수를 local storage 변수에 넣으면 값을 가리키는 주소를 공유해서 서로에게 영향을 줄 수 있음

- storage 와 memory - 값 복사 - storage에 저장된 변수를 memory 변수에 넣으면 값을 복사하므로 서로에게 영향을 주지 않는다.
-그 외의 storage가 포함된 관계 - 값 복사 - 앞에서 언급한 관계를 제외한 storage가 포함된 관계는 갑슬 복사한다. 예를 들어 storage와 storage

스토리지에 저장하는 것보다 이벤트를 통해서 a가 4라는 것을 기록하면 가스 비용을 절약할 수 있다.
이벤트에 기록되면 값을 변경할 수 없다.
이벤트를 통해서 블록체인이 프런트엔드와 쉽게 소통할 수 있다. 함수 외부에 정의한다.
이벤트에는 매개변수가 있으며, 자신이 블록체인에 기록하고자 하는 매개변수를 명시한다.
이벤트 출력은 함수 내부에 명시한다. 함수가 실행되면 특정 이벤트가 출력된다.

함수는 외부에서 아무런 변수를 읽어오지 않았는데도 pure를 붙이지 않았다. 이는 event가 블록체인에 기록되므로 pure나 view를 적용할 수 없다.

생성자를 선언할 때는 오로지 한 개의 생성자만 스마트 컨트랙트에 정의해야 한다.
주로 생성자는 스마트 컨트랙트 배포 시 변수에 특정한 값을 넣어줄 때 활용한다.

constant와 immutable 차이점
- constant와 immutable 두 키워는 변수에 값을 한 번 입력받게 한다. 즉, 변수는 값을 입력받은 순간부터 더 이상 값을 변경할 수 없다.
- 두 키워드의 차이점은 초깃값 명시 여부이다. 상수를 선언할 때 초깃값을 반드시 선언해야 한다.
- immutable은 초깃값을 선언하지 않아도 된다. immutable이 적용된 변수에 초깃값을 선언하지 않아도 되지만, 그 변수에 이미 값이 대입되면 변경할 수 없다.

속성은 객체의 특징을 나타나며 동작은 객체의 함수를 나타낸다.

배열과 같은 참조 타입에는 immutable을 적용할 수 없다.
uint 자료형을 가진 값 타입 변수만 immutable을 적용할 수 있다.

점 연산자로는 함수만 접근 가능하지만, 만약 함수가 private과 internal일 경우에는 접근이 불가능하다. 함수가 public 또는 external일 때만 가능하다.

private은 private이 정의된 스마트 컨트랙트 내부에서만 접근이 가능하며 internal은 internal이 정의된 스마트 컨트랙트 내부와 internal이
정의된 스마트 컨트랙트를 상속받은 자식 스마트 컨트랙트에 한하여 외부 접근이 가능하다.

캡슐화 - 객체 지향의 특징인 캡슐화는 문자 그대로 변수와 변수를 처리하는 함수의 로직을 캡슐로 감싸는 것이다.
캡슐화로 인해 제공되는 함수를 통해서만 변수를 변경하거나 값을 반환할 수 있다. 결론적으로 외부에서 변수를 직접적으로 접근하는 것은 불가능하다.

정보 은닉화는 객체의 속성, 즉 변수에 private을 지정해 외부에서 변수가 보이지 않게 하는 것이다. 다시 말하자면 외부에서
변수의 직접 접근을 막는 것이다.

솔리디티 특성상 public을 변수에 붙이면 public이 적용된 변수의 값을 반환하는 getter 함수가 자동으로 생성된다.

다형성 - 두 함수에서 서로 같은 이름을 가지고 있는 함수라도 서로 다른 자료형을 입력받고 반환한다.
 - 오버로딩 - 하나의 함수가 여러 개의 매개변수를 다룰 수 있으므로 함수를 유연하게 활용할 수 있다.	
 - 오버라이딩 - 자식 스마트 컨트랙트가 부모 스마트 컨트랙트로부터 상속받은 함수를 자신의 상황에 맞게 변경하는 것이다.
    - 부모(virtual), 자식(override)
    - virtual 이 명시되지 않은 부모 스마트컨트랙트의 함수는 오버라이딩 할 수 없다.

super - 상속받은 함수의 로직을 갖고 온다. 본래 함수의 모든 로직을 갖고 올 수 있다.

delete는 Solidity에서 변수나 배열의 값을 삭제하고 초기화하는 데 사용되는 키워드입니다. delete를 사용하면 변수나 배열의 값을 기본값으로 설정하고 저장 공간을 해제합니다.
위의 코드에서 delete courses는 courses 배열의 모든 요소를 삭제하고 배열을 초기화하는 역할을 합니다. 따라서 courses 배열의 길이는 0이 됩니다. 그 후 courses.push("English")와 courses.push("Music")를 통해 배열에 새로운 요소를 추가합니다.
delete는 반드시 필요한 부분은 아니지만, 상황에 따라 유용하게 사용될 수 있습니다. 예를 들어, 배열이나 매핑의 기존 요소를 삭제하고 새로운 데이터를 추가할 때 사용할 수 있습니다. 초기화나 재사용을 위해 변수나 배열의 값을 삭제하고 싶을 때 delete를 사용할 수 있습니다.

두 스마트 컨트랙트 모두 Animal을 상속받았으므로 Animal 자료형을 가질 수 있다.
스마트 컨트랙의 다형성은 두 개의 다른 스마트 컨트랙트가 하나의 자료형으로 묶이지만, 다른 결괏값을 반환하는 것이다.

다중 상속 - 한 개 이상의 부모 스마트 컨트랙트를 상속할 때

상속을 할 때 이미 상속받은 변수 또는 함수와 같은 이름의 자식 스마트 컨트랙트에 정의할 경우 오류가 발생한다.
즉, 상속은 부모 컨트랙트의 변수와 함수가 private가 아니라면 자식 컨트랙트로 그 변수와 함수에 상속 받아서 정의되므로 같은 이름의
변수나 함수를 정의하지 말아야 한다.

상속을 받을 때 모든 변수와 함수를 상속받기 때문에 동일한 함수 혹은 변수를 여러 번 명시하게 될 경우 오류가 발생한다.

각 스마트컨트랙 모두 같은 이름을 가지더라도 virtual이 적용되면 자식 스마트 컨트랙트에서는 오버라이딩이 가능하고 각각의 변수를 출력 가능하다.

맨 오른쪽에 명시된 스마트 컨트랙트가 가장 나중에 상속받은 스마트컨트랙트가 된다.

추상화 - 만들고자 하는 여러 개의 스마트 컨트랙트의 공통 함수를 묶어 명시하는 행위다. 개발하고자 하는 스마트 컨트랙트의 기본 설계도
 - 추상(Abstract) - 추상 스마트 컨트랙트의 완전히 구현되지 않은 함수를 명시하는 특성이 자식 스마트 컨트랙트의 설계도가 되는 것이다.
 - 인터페이스(Interface) - 추상 스마트 컨트랙트의 완전히 구현되지 않은 함수를 명시하는 점이 비슷하지만, 많은 제한사항을 가지고 있다.
    - 인터페이스는 인터페이스끼리 상속할 수 없으며 스마트 컨트랙트와 상속해야 한다.
    - 인터페이스는 완전히 구현된 함수를 정의할 수 없으며 완전히 구현되지 않은 함수를 명시해야 한다. 함수의 가시성 지정자는 external
    - 인터페이스는 생성자를 정의할 수 없다.
    - 인터페이스는 상태 변수를 정의할 수 없다.
    - 인터페이스는 모디파이어를 정의할 수 없다.
    - 이러한 제한사항은 인터페이스를 추상 스마트 컨트랙트보다 더 추상적으로 만들며 ABI(Application Binary Interface)와 인터페이스
         간에 아무런 정보의 손실없이 변환이 가능하게 만든다. ABI는 간단하게 스마트 컨트랙트의 정보이다.
    - 인터페이스를 정의할 때 키워드 interface를 가장 먼저 선언해야하고, 완전히 구현되지 않은 함수만 정의가 가능하며, 함수의 가시성 지정자를 external로 명시해야 한다.
    - 상속 받은 스마트 컨트랙에서 가시성 지정자가 external이 아닌 public이며 override 키워드를 선언했다. 일반적으로 public은 external의
         기능도 포함하므로 상속받은 함수의 가시성 지정자가 external이라면 public으로 변경이 가능하다. 상속받은 함수에 override를 쓴 이유는 인터페이스에 함수를 정의할 때 자동으로 virtual이 선언됐기 떄문이다.
추상 스마트 컨트랙트와 인터페이스 로직이 다르다. 추상 스마트컨트랙트의 경우는 version이라는 변수를 선언했지만, 인터페이스에서는 제한사항 중 하나에서 상태 변수를 선언할 수 없는 것이기 때문이다.

[추상화와 인터페이스 차이점]
1. 추상 스마트 컨트랙트는 변수를 선언했고 각 자식 스마트 컨트랙트에서 특정한 값을 대입했다. 하지만 인터페이스는 변수 선언이 불가능해 변수를 선언하지 않는다.
그렇기 때문에, 자식 스마트 컨트랙트에서 변수를 상속받아 특정한 값을 넣어줄 수가 없다. 그렇기 때문에 값을 대입하기보다는 반환하도록 함수에 명시했다.
2. 추상 스마트 컨트랙트에서는 일반 함수 boot를 정의했으나 인터페이스에서는 일반 함수 정의가 불가능해서 boot 함수를 미완성된 함수로 정의했다.

ABI는 스마트 컨트랙트의 정보이며 ABI와 배포된 스마트 컨트랙트의 주소를 통해 배포된 스마트 컨트랙트와 상호작용이 가능하다. 더 나아가 인터페이스는 ABI와 아무런 정보 손실없이 변환이 가능하다.
ABI는 함수를 완전하지 않은 상태로 명시한다는 점에서 인터페이스와 유사하다.

오류 처리(Error handling) - assert, revert, require
assert - 내부적으로 문제가 있을 때 오류를 발생시키도록 설계됐다. 대표적으로 내부적 오류는 0으로 나누어질 때와 배열에 존재하지 않는 인덱스에 접근할 때 발생한다.
revert - 오류가 나는 이유를 메시지로 출력할 수 있다. 즉, 오류와 오류 메시지가 같이 발생하므로 오류가 나는 이유를 쉽게 파악할 수 있다. revert 입력 자체로 오류가 발생하므로 if 조건문과 같이 사용하는 것을 권장한다. 오류가 발생하면 모든 가스 비용을 소비하지 않고 가스비를 환불 받는다.
require - if의 조건문과 revert가 하나로 합쳐진 것이다. if의 조건문과 같이 특정한 조건을 정의할 수 있으며 revert와 같이 오류 메시지를 입력할 수 있다. 오류가 발생하면 revert와 같이 모든 가스비용을 소비하지 않고 가스비를 환불받는다.




예외 처리(Exception handling) - try/catch
try/catch 문을 선언하면 오류가 발생해도 트랜잭션이 실패하지 않고 오류가 발생하면 catch 블록에서 특정한 조치를 취할수 있다.
특정한 조치는 자유롭게 명실 할 수 있어서 오류에 유연하게 대처할 수 있다.
- 함수 내에서 try/catch 문을 정의해야 한다.
- try/catch 를 적용할 수 있는 경우는 함수를 외부에서 호출할 때와 인스턴스화할 때다.
- try/catch문 안에서 오류가 발생했을 때 트랜잭션 실패가 난다. 즉, try/catch문이 작동하지 않는다.

- try는 try/catch 문을 적용할 수 있는 대상, 즉 외부 스마트 컨트랙트에 존재하는 함수와 외부 스마트컨트랙트의 인스턴스화를 명시해 실행
- catch는 try 블록에서 실행된 대상, 즉 외부의 함수나 인스턴스화에 오류가 발생했을 때 발생한 오류를 잡아서 조치를 취해 트랜잭션 실패를 막는다.

try/catch 문에 크게 try, catch Error, catch Panic, catch로 4개의 블록으로 나뉜다??!

catch만 선언되면 오류의 발생지, 즉 revert, require, assert에 상관없이 모든 오류가 catch에 잡혀 쳐리된다.
try/catch 문에서 발생한 오류는 catch 블록에서 처리할 수 없다는 것이다. try 블록에서 오류가 발생하면 catch 블록에서 이 오류를 처리할 수 없어 트랜잭션이 바로 실패한다.


모디파이어는 함수처럼 값을 반환할 수 없다.
모이파이어는 자신의 로직을 2가지 방식으로 함수에 부여할 수 있다. 
 - 첫 번째 방식: 함수의 로직이 실행되기 전에 모디파이어 로직을 실행하는 것이다.
 - 두 번째 방식: 함수의 로직이 끝나고 나서 모디파이어의 로직을 실행하는 것이다.
모디파이어 로직에 require를 선언해 다수의 함수에 제약을 부여한다.
모디파이어를 활용하면 100개의 함수에 대해 일일이 변경하지 않아도 된다. 
모디파이어를 정의하려면 modifier라는 키워드로 시작해 모디파이어명과 매개변수를 선언해준다.
모디파이어 로직을 보면 require와 _; 가 있다.
_; 는 모디파이어가 적용된 함수의 로직을 나타낸다.

함수 내부에 정의된 변수 또는 매개변수만 사용할 때 pure를 함수에 선언한다.
view는 함수 외부에 정의된 상태 변수를 함수로 갖고 올 때 함수에 명시한다.


이넘 - uint8 범위를 가진 상수 집합이며, 0 ~ 255 까지의 값에 자유롭게 이름을 지정할 수 있다. 
값에 이름을 지정한다는 것은 0 ~ 255의 숫자에 상수명을 지정하는 것이다. 각
숫자에 상수명을 지정함으로써 각 숫자가 무엇을 나타내는지 파악할 수 있다.
이넘은 상수의 집합이므로 한 번 정해진 값은 변하지 않는다.

이넘과 require를 같이 활용하면 한 개 이상의 함수를 개발자가 의도한 순서에 맞게 실행되게 통제할 수 있다.


임포트 - 외부 파일에 스마트 컨트랙트, 추상 스마트 컨트랙트, 인터페이스, 라이브러리 등이 작성돼 있다면 임포트를 통해 외부 파일에 있는 요소를 쉽게 불러올 수 있다.

여러개의 스마트 컨트랙트를 하나의 파일에 저장하면 모든 스마트 컨트랙트를 한눈에 보기가 편하고 상속을 바로 할 수 있어서 좋다고 생각하지만, 각 스마트 컨트랙트의 길이가 길어지고 많은 수의 스마트컨트랙트가 한 파일에 저장된다면,
코드에서 원하는 부분을 찾기 어려워 질 수 있다. 그러므로 스마트 컨트랙트별로 파일을 따로 작성한 뒤 import로 불러오는 것이 좋다.


라이브러리 - 스마트컨트랙트의 경우 스토리지에 있는 상태 변수를 저장하거나 변경하지만, 라이브러리는 상태 변수를 변경하는 용도가 아닌 특정한 값을 입력받아 정의된 함수 로직에 따라 연산 후 값을 반환한다.
대표적인 라이브러리 활용 목적은 함수의 재사용성이다. 라이브러리에 다수의 스마트 컨트랙트가 필요로 하는 함수를 정의해 각 스마트 컨트랙트에 공유하는 것이다.

라이브러리 특징
 - 코드의 재사용과 가스 절약에 이점이 있다. 각 스마트 컨트랙트는 하나의 라이브러리를 공유해 함수를 호출한다. 다수의 스마트 컨트랙트에 똑같은 함수를 정의한다면 각 스마트 컨트랙트마다 중복적으로 정의해야 하지만, 라이브러리는 한 번만 정의하면 되기 때문이다.
 - 자료형에 적용 가능하다.
 - 상태변수와 상속의 정의가 불가능하다. 라이브러리가 적용된 스마트 컨트랙트는 pure와 view를 가진 라이브러리 함수를 호출한다.
 - 정의된 함수가 internal과 external일 경우 내부적으로 다르게 적용한다. 
 - 이더를 받을 수 없다. 라이브러리는 이더를 받을 수 없으므로 fallback과 receive 함수, 그리고 payable 키워드를 명시할 수 없다.

라이브러리는 함수외부에 정의된 변수, 즉 상태 변수, 상속, 폴백 함수, payable은 사용할 수 없으며 라이브러리에 선언된 함수에는 pure나 view가 적용된다.
정의한 라이브러리를 스마트 컨트랙에 적용하려면 using 구문을 사용한다.

상수를 갖고 올 때는 pure를 명시해야 한다.
SafeMath 를 적용하면 asser에서 발생하지 않고 require를 통해 발생하게 조건을 만들어 놓았으므로 assert에서 발생한 오류보다 적은 양의 가스를 소비할 것이다.


address 자료형 - 솔리디티의 주소형 타입 address 는 20바이트의 고정 크기이며 주소는 16진수로 표현된다. 또한, 16진수 1개당 4비트이며 8비트는 1바이트이다. 따라서 주소는 총 40개의 16진수 조합이다.
- EOA(Externally Owned Account) - 사람의 주소, 즉 외부 소유 계정이라 부른다. 암호화폐 지갑을 통해 개인 주소인 EOA를 발급받을 수 있
EOA는 keccak-256을 통해 해시화된 공개키의 마지막 20바이트다.

- CA(Contract Account) - 스마트 컨트랙트. 스마트 컨트랙트 배포 시 생성된다.
CA는 트랜잭션을 준 사람의 주소와 논스를 keccak-256 알고리즘을 통해 해시화한 것이다.

논스 - 블록체인의 다음 블록의 해시값을 찾으려고 임의로 대입하는 숫자. 즉 블록체인의 다음 블록을 찾으려면 논스를 임의로 대입해 그 다음 블록의 해시값을 계산한다.

솔리디티는 keccak-256 알고리즘을 통해 해시화한다. 해시화는 평문을 암호화 하는 것을 말한다.

payable - 주소형 타입과 함수에 적용 가능하다. 이 키워드가 주소에 적용되면 이더를 받을 수 있는 주소를 나타낸다.즉 일반적으로 payable이 적용되지 않는 주소는 이더를 받을 수 없다.
그러나 예외적으로 call 함수를 통해 payable이 적용되지 않은 주소에 이더를 보낼 수 있다.

함수에 payable이 적용되면 함수 호출과 동시에 이더를 전송할 수 있다.




*********
Library Math{
  function add(uint8 a, uint8 b) internal pure returns (uint8) {
    require(a+b >=a, "Error: addition overflow");
    return a+b;
  }
}

라이브러리 Math에는 pure가 적용된 함수 add가 정의돼 있다. add 함수는 uint8 자료형을 가진 매개변수 a와 b를 받으며, add 함수의 로직 require 의 조건 a+b >=b b는 a와 b의 합이 오버플로인지 아닌지를 확인해 a와 b의 값을 반환한다.

require의 조건 a+b >= b를 자세히 살펴보면 a가 uint8의 최대값 255이며, b가 1이라면 a와 b의 합은 256이 된다. 그러나 uint 8은 255가 제일 큰 수 이므로 256은 uint8에서 1정도 오버플로우가 발생해 0이 될 것 이다.
즉, a+b >= b의 a+b 는 0이고, a는 255가 되므로 0>255가 돼 require에서 오류가 발생해 오버플로를 방지한다.
*********


*********
contract Ex8_6 {
    using Math for uint8;

    // 255 + 1 = 0 , overflow 발생
    function overflow(uint8 _num1, uint8 _num2) public pure returns(uint8) {
        return _num1 + _num2;
    }

    // 255 + 1 = "VM error: revert." , overflow 발생하지 않고 오류가 발생할 것을 예상상
    function noOverflow1(uint8 _num1, uint8 _num2) public pure returns(uint8) {
        return Math.add(_num1, _num2);
    }
    
    // 255 + 1 = "VM error: revert." , overflow 발생하지 않고 오류가 발생할 것을 예상상
    function noOverflow2(uint8 _num1, uint8 _num2) public pure returns(uint8) {
        return _num1.add(_num2);
    }
}
********


using SafeMath for uint를 통해 자료형 uint에 SafeMath를 적용하고 있다. 상수 MAX_UINT는 ~uint(0)를 통해 uint의 최댓값을 나타낸다. 
~uint(0)의 ~는 비트 연산자이며 비트 0을 1로, 또는 1을 0으로 반전시킨다.

SafeMath에 의해서 오류가 발생해 트랜잭션이 실패할 것이다. 결론적으로 오버플로는 발생하지 않는다.

상수 MAX_UINT를 함수 외부에서 읽어 왔지만, view가 아닌 pure를 쓴 이유는 상수를 갖고 올 때는 pure를 명시해야 한다.


스마트 컨트랙트의 주소로 이더를 받으려면 fallback 또는 receive 함수가 필요하며 이 두 함수 역시 payable을 적용해야 한다. 
키워드 payable은 이더를 받는 주소 또는 이더의 수신을 돕는 모디파이어가 아니라 현재 사용하는 블록체인네트워크으 ㅣ대표 암호화폐의 수신을 돕는다.
추가로 ERC20과 같은 일반적인 토큰은 payable을 붙일 필요가 없다.

msg.sender - 현재 호출한 메시지 발신자를 나타낸다. 즉 현재 트랜잭션을 발생시킨 대상이다.
msg.sender는 상대적이다.

전역 변수 msg.value(전송된 금액)는 메시지와 함께 전송된 wei의 개수를 나타낸다. 즉 msg.value는 함수를 호출하면서 전송된 이더를 wei 단위로 표현한 것이다.
msg.value는 전송된 wei를 나타내므로 함수에 msg.value를 명시한다면 모디파이어 payable을 적용해야 한다.

address.balance(현재 잔액)

**************

    function getMsgValue() public payable onlyOwner() returns(uint) {
        return msg.value;
    }


ACCOUNT 주소에서 어떻게 컨트랙트로 msg.value 만큼 보낼 수 있는가요 어떤 코드인가요?
**************

이더를 보내는 3가지 함수 : send / call / transfer이고 이들은 주소 타입의 내장 함수이다.
이 3개의 함수를 통해 이더를 특정 주소로 보낸다. 이더를 특정한 주소를 보낸다는 것은 이더리움 네트워크의 주 암호화폐를 누군가에게 전송한다는 것이다.
주소형 타입의 내장 함수이므로 주소가 없다면 이더를 받을 수 없다.

send - 이더를 받는 특정 주소는 키워드 payable이 적용돼야 한다.
     - 이더르 솜그
fallback 또는 receive의 가스량을 2300 gwei로 제한한다.

call - 이더를 받는 특정 주소는 키워드 payable이 적용될 필요가 없다.
    - 이더의 송금 결과를 true 또는 false로 반환된다.
       - 함수 fallback 또는 receive의 가스 소비량은 가변적이다.

transfer - 이더를 받는 특정 주소는 키워드 payable 이 적용돼야 한다.
         - 이더 송금 실패 시 트랜잭션이 실패한다.
 	 - 함수 fallback 또는 receive() 의 가스 소비량을 20pgii


스마트 컨트랙트의 주소인 CA로 보내려면 스마트 컨트랙트에 함수 fallback 또는 receive를 명시해야 한다.

키워드 payable의 적용을 떠나서 이더를 받을 수 있는 가장 기본적인 조건은 자신만의 주소를 소유하는 것이다.

call 함수는 send와 transfer와 다르게 송금받는 주소는 payable을 따로 적용할 필요가 없다. 도한, call 함수를 정의할 때 끝 부분이("")dlek. call 함수를 활용해 이더를 보낼 때는 ("")와 같이 데이터를 따로 보내줄 필요가 없기 때문이다.
call 함수는 단순히 이더를 보내는 기능만 하는 것이 아니라 외부 스마트 컨트랙트의 함수를 호출한다.

솔리디티는 이더의 단위 ether, gwei, wei를 코드로 지원하며 각 단위는 wei로 변환돼 출력된다.

transfer는 require를 따로 명시할 필요가 없다.
msg.value는 전송된 wei를 나타내므로 자유롭게 송금 금액을 입력해 특정 주소로 보낼 수 있다.


(bool result, ) = _address.call{value:msg.value, gas: 30000}("");에서 call 함수는 2개의 반환 값을 가지고 있다.
첫 번째는 call 함수의 성공 여부를 true, false로 출력하며 두 번째는 호출한 함수의 결괏값을 bytes형으로 반환한다. 함수를 호출하지 않았으므로 bytes형의 값을 따로 받지 않고 call 함수의 성공 여부만 받도록 하겠다.
이는 곧 이더가 성공적으로 보내졌는지 파악할 수 있는 결괏값이다. call 함수의 결괏값만 받으려("")인 것을 알수 있으며 현재 따로 함수를 호출하지 않으므로 입력해줄 필요가 없다.

_addess.call{value:msg.value, gas:30000}("")를 보면 송금 받을 주소의 _address는 따로 payable을 명시하지 않아도 된다. call 함수의 value는 송금할 wei를 나타내며 이 call의 value는 msg.value이므로 ethDelivery1 함수가 실행될 때 전송된 wei가 _address에 보내질 것이다.


스마트컨트랙트가 이더를 받으려면 솔리디티 버전 0.6 전후로 무기명 함수 fallback 또는 receive를 선언해야 한다.
fallback 함수는 이더를 받는 기능과 존재하지 않는 함수가 호출 될 때 처리하는 기능이 있다. 외부에서 존재하지 않는 함수가 호출될 때 대처하는 기능은 ~~

기능(2)
 - CA로 전송된 이더를 받는 기능
이더를 보낸 사람의 주소를 따로 저장하고 싶다면 fallback 함수 로직에 특정 이벤트를 정의해 이더 송금자의 주소를 출력할 수 있다.
fallback함수가 실행된다는 것은 가스를 소비해서 실행된다는 것이다. fallback 함수는 함수 send, call, transfer 로부터 가스를 받는다. 함수 send와 transfer는 2300 gwei를 fallback 함수에게 제공하며 call 함수는 사용할 수 있는 모든 가스를 제공한다.
향후 가스비가 오를 경웅를 대비해서 call 함수를 통해 이더를 보내는 것이 권장된다. 즉 2300 gwei로는 함수 fallback의 로직을 실행하기 힘들 수 있다.

- 스마트 컨트랙트에 존재하지 않는 함수가 불렸을 때 대신 호출을 받는 기능
fallback 함수는 대비책 함수다. 스마트 컨트랙트 내에 존재하지 않는 함수가 호출 될 때 fallback 함수가 대신 호출한다. 

하나의 fallback 함수로 위 2가지 기능을 모두 수행하기 어려움이 존재한다. 이러한 어려움을 해소하고자 receive 함수가 새롭게 도입됐다. 즉 기존 2가지 일을 했던 fallback 입장에서는 receive 와 일을 분담한다고 생각할 수 있다.

receive는 스마트 컨트랙트가 이더를 받을 수 있도록 돕고, fallback은 스마트 컨트랙트에 존재하지 않는 함수가 호출됐을 때 대처한다.
솔리디티 버전 0.6 이상에서 fallback 함수는 이더를 받는 기능이 사라진 것이 아니라 이더를 받는 함수 receive가 새롭게 추가된 것이다. 즉 특정 스마트 컨트랙트에 receive를 정의하지 않고 fallback에 payable을 붙여 정의하면 스마트컨트랙트는 여전히 이더를 받을 수 있다.


솔리디티 버전 0.6 fallback 함수 정의 방법
function() external payable {
// fallback 함수 로직
}
// fallback 함수는 무기명 함수이므로 함수명을 적지 않고, 가시성 지정자 external은 필수적으로 명시해야 한다. payable이 있으므로 함수가 정의된 스마트 컨트랙트는 이더를 받을 수 있다.


**********
무기명 함수(anonymous function)에서 반환값은 외부로부터의 호출에 응답하는 값입니다. 이러한 함수는 특정 이름이나 시그니처 없이 선언되며, 일반적으로 스마트 컨트랙트에 이더를 전송하거나 특정 이벤트를 발생시키는 데 사용됩니다.

무기명 함수는 function() external payable { ... }와 같이 선언됩니다. 이 경우, 함수는 payable 키워드가 있는데, 이는 이더를 받을 수 있는 함수임을 의미합니다. 그리고 함수 내에서는 msg.sender와 msg.value를 사용하여 호출자의 주소와 전송된 이더의 값에 접근할 수 있습니다.

예를 들어, 주어진 코드에서 무기명 함수는 Obtain 이벤트를 발생시키는 역할을 합니다. 이벤트는 외부로부터의 호출에 응답하여 특정 정보를 기록하는 데 사용됩니다. 함수가 호출될 때마다 msg.sender와 msg.value를 이벤트의 인수로 사용하여 이더를 보낸 주소와 전송된 이더의 양을 기록합니다.

따라서, 무기명 함수의 반환값은 외부 호출자에게 반환되지 않으며, 주로 이벤트를 발생시키거나 스마트 컨트랙트의 상태를 변경하는 데 사용됩니다.
**********

솔리디티 0.6 이상부터 무기명 fallback 함수는 receive와 fallback 함수로 나뉜다. 기존 fallback 함수는 이더를 받으며 존재하지 않는 함수가 호출될 때 대신 실행된다.
receive 함수가 이더를 받으며 fallback 함수는 스마트 컨트랙트에 존재하지 않는 함수가 호출될 때 처리한다. 

솔리디티 0.6 이상의 함수 receive의 특징
 - 함수를 시작하는 키워드 function 없이 receive()만 입력한다.
 - receive 함수에 가시성 지정자 external을 필수로 붙여야 한다.
 - receive 함수에 모디파이어 payable 을 필수로 붙여야 한다.
 - receive 함수는 매개변수가 존재하지 않는다.
 - 반환 값이 존재하지 않는다.
 - 하나의 스마트 컨트랙트는 하나의 receive 함수를 수용할 수 있다.
 - receive 함수에 키워드 virtual과 override 적용이 가능하므로 오버라이딩이 가능하다.
 - receive 함수에 추가로 모디파이어를 적용할 수 있다.
 - receive 함수는 스마트 컨트랙트가 이더를 받을 수 있게 도와준다.

스마트 컨트랙트가 이더를 받으면 receive함수가 실행된다. send와 transfer 함수를 통해 이더를 받은 경우 2300 gwei만큼 가스를 소비해 receive 함수가 실행된다.
그러나 2300 gwei는 receive 함수를 실행하기에 가스가 부족할 수 있다. 예를 들어 receive 함수의 로직이 특정 변수의 값을 저장하거나 받은 이더를 다른 곳으로 보낸다면 가스 2300 gwei로 receive 함수를 실행할 수가 없어서 트랜잭션에 실패할 것이다.
이러한 문제를 해소하려면 call 함수를 사용해서 이더를 보낸다. call 함수는 receive 함수에게 현재 소비할 수 있는 모든 가스를 제공한다.

receive() external payable {
// receive 함수 로직
}

receive 함수를 정의 시 function 키워드를 붙일 필요가 없으며 가시성 지정자 external과 payable 은 필수적으로 명시한다.

솔리디티 버전 0.6 이상의 함수 fallback 특징
 - 함수를 시작하는 키워드 function 없이 fallback() 만 입력한다.
 - fallback 함수에 가시성 지정자 external을 필수로 붙여야 한다.
 - fallback 함수에 모디파이어 payable 을 선택적으로 붙일 수 있다.
    fallback 함수에 payable을 적용하지 않으면 존재하지 않는 함수가 호출됐을 때 fallback 함수가 실행된다.
    fallback 함수에 payable을 적용하고 receive 함수가 정의되지 않았다면 fallback 함수를 통해 이더를 받을 수 있다. send와 transfer함수를 통해 이더를 받는 경우 fallback 함수는 2300 gwei 가스를 소비해 실행된다.
 - fallback 함수는 매개변수가 존재하지 않는다.
 - 반환값이 존재하지 않는다
 - 하나의 스마트 컨트랙트는 하나의 fallback 함수를 수용할 수 있다.
 - fallback 함수에 키워드 virtual과 override 적용이 가능하므로 오버라이딩이 가능하다.
 - fallback 함수에 추가로 모디파이어를 적용할 수 있다.

fallback() external payable {
// fallback 함수 로직
}



Ex9_8 의 생성자는 payable이 적용될 시 Ex9_8 스마트 컨트랙트가 배포와 동시에 이더를 받을 수 있다는 점이다.
constructor() payable {
}


주소형 타입의 내장 함수 call과 delegatecall. 두 함수는 문법은 같으나 작동하는 방식이 다르다. 
call 함수 - 이더를 보내는 기능만 하는 것이 아니라 외부 스마트 컨트랙트의 함수 호출을 할 수 있다. 
이더를 보내면서 함수 호출도 가능하다.

call 함수를 통해 외부 스마트 컨트랙트에 정의된 함수를 호출하는 방법이다. 원하는 함수를 호출하려면 그 함수가 존재하는 스마트 컨트랙트의 주소를 알아야 하며 그 스마트 컨트랙트 주소에 점 연산자를 이용해 call 함수를 적용한다.
그리고나서 abi.encodeWithSignature를 통해 호출하고자 하는 함수를 명시한다.

함수에 매개변수가 있다면 매개변수의 자료형을 명시해줘야 한다. uint와 같이 uint256을 나타내는 축약 단어는 사용할 수 없으며, 매개변수 사이에 띄어쓰기도 없어야 한다.
매개변수 사이에 띄어쓰기 없이 uint256으로 정확하게 명시해야 한다.

정의 방법
- 이더를 보내는 call
(송금받는 주소).call{value:1000}("")
- 함수를 호출 하는 call
(외부 스마트 컨트랙트 주소).call(abi.encodeWithSignature("add(uint256, uint256)", 10, 15))
 // "add(uint256, uint256 : 호출하려는 함수
 // 10, 15 : 함수의 매개변수



Receiver 스마트 컨트랙트는 이더를 받게 도와주는 receive함수가 없으며 fallback함수는 payablee이 적용되지 않은 상태이므로 해당 스마트 컨트랙트는 이더를 받을 수 없는 상태이다.
그러나 함수를 호출하면서 이더를 보낼 때 receive 함수 또는 payable이 적용된 fallback 함수는 필요하지 않다.
함수 ouPut에 payable을 적용하면 이 함수가 호출되면섯 Receiver 스마트 컨트랙트가 이더를 받을 수 있다.
즉 호출하려는 함수에 payable을 적용하면 그 함수를 호출하면서 스마트 컨트랙트에 이더를 줄 수 있다.


주소형 타입의 내장 함수 Delegatecall
함수 Delegatecall 는 call 과 다르게 이더를 보낼 수 없지만, call과 같이 외부 스마트 컨트랙트에 존재하는 함수를 호출할 수 있다.
call 과 delegatecall은 외부 함수를 호출할 수 있다는 점에서 같지만, 함수를 호출하는 방식이 다르다

delegatecall로 호출된 함수의 로직만 실행해 호출된 함수의 결괏값을 UserInfo와 같은 delegatecall이 명시된 스마트 컨트랙트에 값을 저장한다. 더 나아가서 delegatecall로 호출한 함수의 msg.sender는 UserInfo의 주소가 아닌 맨 처음 트랜잭션을 준 것의 주소이다.

delegatecall 함수를 통해 외부 스마트 컨트랙트에 있는 함수를 호출하면 그 함수의 로직만 실행되고 결괏값은 delegatecall이 명시된 스마트 컨트랙트에 저장된다. 즉, 로직에 있는 외부 스마트 컨트랙트에 저장된 정보가 없기에 새로운 로직을 가진
스마트 컨트랙트를 배포해서 사용할 수 있다.


